# SOLID

## Single-responsibility principle
Uma classe, componente, função, deve ter apenas uma responsabilidade. Assim você consegue refatorar, reaproveitar facilmente, isolar problemas, testar melhor.

## Open-closed principle
Uma classe deve estar aberta para extensão, mas fechada para modificação. É como se fossem extensões ou plugins. Aberto para adicionar novas funcionalidades, mas a base não é alterada.

## Liskov substitution principle
Uma classe deve ser substituível por sua superclasse. Ou seja, o filho, criado do pai por meio da herança, deve ser capaz de substituir o pai.

## Interface segregation principle
Clientes não devem ser forçados a depender de métodos que eles não usam. Há várias tarefas, e quem puder executa-la que a execute.

## Dependency inversion principle
Um módulo não deve depender de detalhes de implementação de outro módulo diretamente. Deve haver uma interface entre eles.
